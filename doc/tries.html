
<HTML>
<TITLE>Documentation for the TRIES package</TITLE>
<H2>Documentation for the TRIES package</H2>

This document contains documentation for the <code>TRIES</code> package,
which is a utility package shipped with the OKBC release.<P>

This software implements an efficient key-to-value mapping data structure
that will typically give much better performance than <code>equal</code>
hash-tables.<p>

Two distinct variants of the <code>TRIE</code> data structure are supplied
with API for each.  One implementation, called <code>trie</code> uses cons
cells very efficiently so as to implement the TRIE discrimination net in
as space-efficient a manner as possible.  The result is a data structure that
is consp, and whose contents are effectively unintelligible to anyone,
but for which the API works fine.  You can freely use this implementation
for any application for which you will feel no need to delve inside the
TRIE itself.<P>

A second implementation, called <code>structure-trie</code> implements the same
data structure concepts and an equivalent API using defstruct for the nodes
in the discrimination net.  This is less space efficient, but has the
advantage that you can see better what's going on in the inspector and
debugger.  Another advantage of this version is that you can subclass the
<code>structure-trie</code> defstruct.  The implementation provides an
example of this called <code>root-trie</code> which is useful as the root
node of a trie data structure.<P>

The APIs for these two versions of the data structure are disjoint.  For each
operation on <code>trie</code>s called, say, <code>trie-foo</code> there is
a conforming <code>structure-trie-foo</code>.<p>

A further set of API is provided to allow the use of hybrid trie structures
that mix the two data structure variants.  In this version, the API is
implemented as CLOS methods (called <code>hybrid-trie-foo</code>, so using
this approach will allow you to achieve the best space efficiency whilst
still being able to use <code>structure-trie</code> subclass nodes to store
extra application-specific data.  The downside of this approach is that the
accesses to the data structures are slower than they would be for either of
the more specialized cases.<P>

If you use the hybrid trie operations, you can switch in your code between
using the cons or the defstruct variant simply by switching a feature
and recompiling.  Adding the <code>use-minimal-tries</code> feature will give
the most space-efficient version.<P>

Note that when using the hybrid trie operations, <code>structure-trie</code>s
can point to <code>trie</code>s, but <i>not</i> vice versa.  This gives the
best all-round space efficiency.<P>

Note also that the tries will automatically switch into using hash tables
when necessary.  When they do so, they use the
<code>ok-utils:fast-hash-key</code> index function to extract the hash key.
Specializing this generic function as appropriate for your application will
deliver the best performance from your tries.
<H3>Table of Contents:</H3>
<OL>
  <LI><A HREF="#+no-value+"><code>+no-value+</code></A>
  <LI><A HREF="#copy-deep-hybrid-trie"><code>copy-deep-hybrid-trie</code></A>
  <LI><A HREF="#copy-deep-structure-trie"><code>copy-deep-structure-trie</code></A>
  <LI><A HREF="#copy-deep-trie"><code>copy-deep-trie</code></A>
  <LI><A HREF="#delete-hybrid-trie"><code>delete-hybrid-trie</code></A>
  <LI><A HREF="#delete-structure-trie"><code>delete-structure-trie</code></A>
  <LI><A HREF="#delete-trie"><code>delete-trie</code></A>
  <LI><A HREF="#delinearize-sexpr"><code>delinearize-sexpr</code></A>
  <LI><A HREF="#dismantle-hybrid-trie"><code>dismantle-hybrid-trie</code></A>
  <LI><A HREF="#dismantle-structure-trie"><code>dismantle-structure-trie</code></A>
  <LI><A HREF="#dismantle-trie"><code>dismantle-trie</code></A>
  <LI><A HREF="#get-hybrid-trie"><code>get-hybrid-trie</code></A>
  <LI><A HREF="#get-hybrid-trie-returning-node"><code>get-hybrid-trie-returning-node</code></A>
  <LI><A HREF="#get-hybrid-trie-returning-node-no-extend"><code>get-hybrid-trie-returning-node-no-extend</code></A>
  <LI><A HREF="#get-structure-trie"><code>get-structure-trie</code></A>
  <LI><A HREF="#get-structure-trie-returning-node"><code>get-structure-trie-returning-node</code></A>
  <LI><A HREF="#get-structure-trie-returning-node-no-extend"><code>get-structure-trie-returning-node-no-extend</code></A>
  <LI><A HREF="#get-trie"><code>get-trie</code></A>
  <LI><A HREF="#get-trie-returning-node"><code>get-trie-returning-node</code></A>
  <LI><A HREF="#get-trie-returning-node-no-extend"><code>get-trie-returning-node-no-extend</code></A>
  <LI><A HREF="#hybrid-trie-all-values"><code>hybrid-trie-all-values</code></A>
  <LI><A HREF="#hybrid-trie-arcs"><code>hybrid-trie-arcs</code></A>
  <LI><A HREF="#hybrid-trie-arcs-hashed-p"><code>hybrid-trie-arcs-hashed-p</code></A>
  <LI><A HREF="#hybrid-trie-node-count"><code>hybrid-trie-node-count</code></A>
  <LI><A HREF="#hybrid-trie-stash"><code>hybrid-trie-stash</code></A>
  <LI><A HREF="#hybrid-trie-value"><code>hybrid-trie-value</code></A>
  <LI><A HREF="#linearize-sexpr"><code>linearize-sexpr</code></A>
  <LI><A HREF="#make-hybrid-trie"><code>make-hybrid-trie</code></A>
  <LI><A HREF="#make-root-trie"><code>make-root-trie</code></A>
  <LI><A HREF="#make-structure-trie"><code>make-structure-trie</code></A>
  <LI><A HREF="#make-trie"><code>make-trie</code></A>
  <LI><A HREF="#make-trie-remove-duplicate-state"><code>make-trie-remove-duplicate-state</code></A>
  <LI><A HREF="#maphybrid-trie"><code>maphybrid-trie</code></A>
  <LI><A HREF="#maphybrid-trie-nodes"><code>maphybrid-trie-nodes</code></A>
  <LI><A HREF="#maphybrid-trie-nodes-remove-if"><code>maphybrid-trie-nodes-remove-if</code></A>
  <LI><A HREF="#maphybrid-trie-values"><code>maphybrid-trie-values</code></A>
  <LI><A HREF="#mapstructure-trie"><code>mapstructure-trie</code></A>
  <LI><A HREF="#mapstructure-trie-nodes"><code>mapstructure-trie-nodes</code></A>
  <LI><A HREF="#mapstructure-trie-nodes-remove-if"><code>mapstructure-trie-nodes-remove-if</code></A>
  <LI><A HREF="#mapstructure-trie-values"><code>mapstructure-trie-values</code></A>
  <LI><A HREF="#maptrie"><code>maptrie</code></A>
  <LI><A HREF="#maptrie-nodes"><code>maptrie-nodes</code></A>
  <LI><A HREF="#maptrie-nodes-remove-if"><code>maptrie-nodes-remove-if</code></A>
  <LI><A HREF="#maptrie-values"><code>maptrie-values</code></A>
  <LI><A HREF="#member-using-state"><code>member-using-state</code></A>
  <LI><A HREF="#new-root-hybrid-trie"><code>new-root-hybrid-trie</code></A>
  <LI><A HREF="#new-root-trie"><code>new-root-trie</code></A>
  <LI><A HREF="#pushnew-using-state"><code>pushnew-using-state</code></A>
  <LI><A HREF="#reconstitute-from-hash-key"><code>reconstitute-from-hash-key</code></A>
  <LI><A HREF="#remove-duplicates-equal-using-structure-trie"><code>remove-duplicates-equal-using-structure-trie</code></A>
  <LI><A HREF="#remove-duplicates-equal-using-structure-trie*"><code>remove-duplicates-equal-using-structure-trie*</code></A>
  <LI><A HREF="#remove-duplicates-equal-using-trie"><code>remove-duplicates-equal-using-trie</code></A>
  <LI><A HREF="#remove-duplicates-equal-using-trie*"><code>remove-duplicates-equal-using-trie*</code></A>
  <LI><A HREF="#remove-duplicates-using-state"><code>remove-duplicates-using-state</code></A>
  <LI><A HREF="#remove-duplicates-using-structure-trie-and-coercion"><code>remove-duplicates-using-structure-trie-and-coercion</code></A>
  <LI><A HREF="#remove-duplicates-using-trie-and-coercion"><code>remove-duplicates-using-trie-and-coercion</code></A>
  <LI><A HREF="#remove-using-state"><code>remove-using-state</code></A>
  <LI><A HREF="#root-trie"><code>root-trie</code></A>
  <LI><A HREF="#root-trie-purpose"><code>root-trie-purpose</code></A>
  <LI><A HREF="#root-trie-up"><code>root-trie-up</code></A>
  <LI><A HREF="#set-hybrid-trie-value"><code>set-hybrid-trie-value</code></A>
  <LI><A HREF="#set-structure-trie-value"><code>set-structure-trie-value</code></A>
  <LI><A HREF="#set-trie-value"><code>set-trie-value</code></A>
  <LI><A HREF="#structure-trie"><code>structure-trie</code></A>
  <LI><A HREF="#structure-trie-all-values"><code>structure-trie-all-values</code></A>
  <LI><A HREF="#structure-trie-arcs"><code>structure-trie-arcs</code></A>
  <LI><A HREF="#structure-trie-arcs-hashed-p"><code>structure-trie-arcs-hashed-p</code></A>
  <LI><A HREF="#structure-trie-node-count"><code>structure-trie-node-count</code></A>
  <LI><A HREF="#structure-trie-p"><code>structure-trie-p</code></A>
  <LI><A HREF="#structure-trie-value"><code>structure-trie-value</code></A>
  <LI><A HREF="#trie-all-values"><code>trie-all-values</code></A>
  <LI><A HREF="#trie-arcs"><code>trie-arcs</code></A>
  <LI><A HREF="#trie-arcs-hashed-p"><code>trie-arcs-hashed-p</code></A>
  <LI><A HREF="#trie-node-count"><code>trie-node-count</code></A>
  <LI><A HREF="#trie-remove-duplicate-state"><code>trie-remove-duplicate-state</code></A>
  <LI><A HREF="#trie-remove-duplicate-state-count"><code>trie-remove-duplicate-state-count</code></A>
  <LI><A HREF="#trie-remove-duplicate-state-unique"><code>trie-remove-duplicate-state-unique</code></A>
  <LI><A HREF="#trie-value"><code>trie-value</code></A>
</OL>
<HR>
<H3>Table of Variables:</H3>
<OL>
  <LI><A HREF="#+no-value+"><code>+no-value+</code></A>
</OL>
<HR>
<H3>Table of Classes and Defstructs:</H3>
<OL>
  <LI><A HREF="#root-trie"><code>root-trie</code></A>
  <LI><A HREF="#structure-trie"><code>structure-trie</code></A>
  <LI><A HREF="#trie-remove-duplicate-state"><code>trie-remove-duplicate-state</code></A>
</OL>
<HR>
<H3>Table of Functions:</H3>
<OL>
  <LI><A HREF="#copy-deep-hybrid-trie"><code>copy-deep-hybrid-trie</code></A>
  <LI><A HREF="#copy-deep-structure-trie"><code>copy-deep-structure-trie</code></A>
  <LI><A HREF="#copy-deep-trie"><code>copy-deep-trie</code></A>
  <LI><A HREF="#delete-hybrid-trie"><code>delete-hybrid-trie</code></A>
  <LI><A HREF="#delete-structure-trie"><code>delete-structure-trie</code></A>
  <LI><A HREF="#delete-trie"><code>delete-trie</code></A>
  <LI><A HREF="#delinearize-sexpr"><code>delinearize-sexpr</code></A>
  <LI><A HREF="#dismantle-hybrid-trie"><code>dismantle-hybrid-trie</code></A>
  <LI><A HREF="#dismantle-structure-trie"><code>dismantle-structure-trie</code></A>
  <LI><A HREF="#dismantle-trie"><code>dismantle-trie</code></A>
  <LI><A HREF="#get-hybrid-trie"><code>get-hybrid-trie</code></A>
  <LI><A HREF="#get-hybrid-trie-returning-node"><code>get-hybrid-trie-returning-node</code></A>
  <LI><A HREF="#get-hybrid-trie-returning-node-no-extend"><code>get-hybrid-trie-returning-node-no-extend</code></A>
  <LI><A HREF="#get-structure-trie"><code>get-structure-trie</code></A>
  <LI><A HREF="#get-structure-trie-returning-node"><code>get-structure-trie-returning-node</code></A>
  <LI><A HREF="#get-structure-trie-returning-node-no-extend"><code>get-structure-trie-returning-node-no-extend</code></A>
  <LI><A HREF="#get-trie"><code>get-trie</code></A>
  <LI><A HREF="#get-trie-returning-node"><code>get-trie-returning-node</code></A>
  <LI><A HREF="#get-trie-returning-node-no-extend"><code>get-trie-returning-node-no-extend</code></A>
  <LI><A HREF="#hybrid-trie-all-values"><code>hybrid-trie-all-values</code></A>
  <LI><A HREF="#hybrid-trie-arcs"><code>hybrid-trie-arcs</code></A>
  <LI><A HREF="#hybrid-trie-arcs-hashed-p"><code>hybrid-trie-arcs-hashed-p</code></A>
  <LI><A HREF="#hybrid-trie-node-count"><code>hybrid-trie-node-count</code></A>
  <LI><A HREF="#hybrid-trie-stash"><code>hybrid-trie-stash</code></A>
  <LI><A HREF="#hybrid-trie-value"><code>hybrid-trie-value</code></A>
  <LI><A HREF="#linearize-sexpr"><code>linearize-sexpr</code></A>
  <LI><A HREF="#make-root-trie"><code>make-root-trie</code></A>
  <LI><A HREF="#make-structure-trie"><code>make-structure-trie</code></A>
  <LI><A HREF="#make-trie"><code>make-trie</code></A>
  <LI><A HREF="#make-trie-remove-duplicate-state"><code>make-trie-remove-duplicate-state</code></A>
  <LI><A HREF="#maphybrid-trie"><code>maphybrid-trie</code></A>
  <LI><A HREF="#maphybrid-trie-nodes"><code>maphybrid-trie-nodes</code></A>
  <LI><A HREF="#maphybrid-trie-nodes-remove-if"><code>maphybrid-trie-nodes-remove-if</code></A>
  <LI><A HREF="#maphybrid-trie-values"><code>maphybrid-trie-values</code></A>
  <LI><A HREF="#mapstructure-trie"><code>mapstructure-trie</code></A>
  <LI><A HREF="#mapstructure-trie-nodes"><code>mapstructure-trie-nodes</code></A>
  <LI><A HREF="#mapstructure-trie-nodes-remove-if"><code>mapstructure-trie-nodes-remove-if</code></A>
  <LI><A HREF="#mapstructure-trie-values"><code>mapstructure-trie-values</code></A>
  <LI><A HREF="#maptrie"><code>maptrie</code></A>
  <LI><A HREF="#maptrie-nodes"><code>maptrie-nodes</code></A>
  <LI><A HREF="#maptrie-nodes-remove-if"><code>maptrie-nodes-remove-if</code></A>
  <LI><A HREF="#maptrie-values"><code>maptrie-values</code></A>
  <LI><A HREF="#member-using-state"><code>member-using-state</code></A>
  <LI><A HREF="#new-root-hybrid-trie"><code>new-root-hybrid-trie</code></A>
  <LI><A HREF="#new-root-trie"><code>new-root-trie</code></A>
  <LI><A HREF="#pushnew-using-state"><code>pushnew-using-state</code></A>
  <LI><A HREF="#reconstitute-from-hash-key"><code>reconstitute-from-hash-key</code></A>
  <LI><A HREF="#remove-duplicates-equal-using-structure-trie"><code>remove-duplicates-equal-using-structure-trie</code></A>
  <LI><A HREF="#remove-duplicates-equal-using-structure-trie*"><code>remove-duplicates-equal-using-structure-trie*</code></A>
  <LI><A HREF="#remove-duplicates-equal-using-trie"><code>remove-duplicates-equal-using-trie</code></A>
  <LI><A HREF="#remove-duplicates-equal-using-trie*"><code>remove-duplicates-equal-using-trie*</code></A>
  <LI><A HREF="#remove-duplicates-using-state"><code>remove-duplicates-using-state</code></A>
  <LI><A HREF="#remove-duplicates-using-structure-trie-and-coercion"><code>remove-duplicates-using-structure-trie-and-coercion</code></A>
  <LI><A HREF="#remove-duplicates-using-trie-and-coercion"><code>remove-duplicates-using-trie-and-coercion</code></A>
  <LI><A HREF="#remove-using-state"><code>remove-using-state</code></A>
  <LI><A HREF="#root-trie-purpose"><code>root-trie-purpose</code></A>
  <LI><A HREF="#root-trie-up"><code>root-trie-up</code></A>
  <LI><A HREF="#set-hybrid-trie-value"><code>set-hybrid-trie-value</code></A>
  <LI><A HREF="#set-structure-trie-value"><code>set-structure-trie-value</code></A>
  <LI><A HREF="#set-trie-value"><code>set-trie-value</code></A>
  <LI><A HREF="#structure-trie-all-values"><code>structure-trie-all-values</code></A>
  <LI><A HREF="#structure-trie-arcs"><code>structure-trie-arcs</code></A>
  <LI><A HREF="#structure-trie-arcs-hashed-p"><code>structure-trie-arcs-hashed-p</code></A>
  <LI><A HREF="#structure-trie-node-count"><code>structure-trie-node-count</code></A>
  <LI><A HREF="#structure-trie-p"><code>structure-trie-p</code></A>
  <LI><A HREF="#structure-trie-value"><code>structure-trie-value</code></A>
  <LI><A HREF="#trie-all-values"><code>trie-all-values</code></A>
  <LI><A HREF="#trie-arcs"><code>trie-arcs</code></A>
  <LI><A HREF="#trie-arcs-hashed-p"><code>trie-arcs-hashed-p</code></A>
  <LI><A HREF="#trie-node-count"><code>trie-node-count</code></A>
  <LI><A HREF="#trie-remove-duplicate-state-count"><code>trie-remove-duplicate-state-count</code></A>
  <LI><A HREF="#trie-remove-duplicate-state-unique"><code>trie-remove-duplicate-state-unique</code></A>
  <LI><A HREF="#trie-value"><code>trie-value</code></A>
</OL>
<HR>
<H3>Table of Macros:</H3>
<OL>
  <LI><A HREF="#make-hybrid-trie"><code>make-hybrid-trie</code></A>
</OL>
<HR>
<DL>
<TABLE width=100%><DT><TR><TD valign=top> <code><B><A NAME="+no-value+">+no-value+</A></B></code><TD valign=top align=right> <I>[variable]</I></TR></TABLE><DD>Special value to indicate that the value cell of a <code><A HREF="#trie">trie</A></code> empty.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="copy-deep-hybrid-trie">copy-deep-hybrid-trie</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>Given a hybrid <code><A HREF="#trie">trie</A></code> or
   <code><A HREF="#structure-trie">structure-trie</A></code> node makes a deep copy of it, copying all nodes
   beneath it, but not copying the values in the nodes themselves.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="copy-deep-structure-trie">copy-deep-structure-trie</A></B></code>  </TD><TD valign=top align=left> (structure-trie) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>Given a <code><A HREF="#structure-trie">structure-trie</A></code> node makes a deep copy
   of it, copying all nodes beneath it, but not copying the values in the
   nodes themselves.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="copy-deep-trie">copy-deep-trie</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Given a <code><A HREF="#trie">trie</A></code> node makes a deep copy of it, copying all nodes
   beneath it, but not copying the values in the nodes themselves.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="delete-hybrid-trie">delete-hybrid-trie</A></B></code>  </TD><TD valign=top align=left> (key trie) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>Given a hybrid <code><A HREF="#trie">trie</A></code> or
   <code><A HREF="#structure-trie">structure-trie</A></code> node, deletes the node associated with
   <code>key</code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="delete-structure-trie">delete-structure-trie</A></B></code>  </TD><TD valign=top align=left> (key structure-trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Marks the entry for <code>key</code> in the <code><A HREF="#structure-trie">structure-trie</A></code> as deleted.
   This does *not* remove the key from the structure-trie. Returns T if key was in the
   structure-trie, else nil.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="delete-trie">delete-trie</A></B></code>  </TD><TD valign=top align=left> (key trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Marks the entry for <code>key</code> in the <code><A HREF="#trie">trie</A></code> as deleted.
   This does *not* remove the key from the trie. Returns T if key was in the
   trie, else nil.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="delinearize-sexpr">delinearize-sexpr</A></B></code>  </TD><TD valign=top align=left> (x) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD><code>X</code> is a linearized sexpression.  Return the sexpression that it
represents.  See <code><A HREF="#linearize-sexpr">linearize-sexpr</A></code>.  Handles lazy linearization in
the form of non-atomic elements.  E.g., <code>(*start* a (b c))</code> is
<code>(a b c)</code>.  An
error is signalled if <code>X</code> does not represent a complete sexpression.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="dismantle-hybrid-trie">dismantle-hybrid-trie</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>Given a hybrid <code><A HREF="#trie">trie</A></code> or
   <code><A HREF="#structure-trie">structure-trie</A></code> node, dismantles all nodes hanging beneath it.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="dismantle-structure-trie">dismantle-structure-trie</A></B></code>  </TD><TD valign=top align=left> (structure-trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Destructively dismantles the <code><A HREF="#structure-trie">structure-trie</A></code> and all of its inferiors.
   There is likely to be no real need for this unless the user has little
   faith in the GC, or pointers were returned to interior nodes.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="dismantle-trie">dismantle-trie</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Destructively dismantles the <code><A HREF="#trie">trie</A></code> and all of its inferiors.
   There is likely to be no real need for this unless the user has little
   faith in the GC, or pointers were returned to interior nodes.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="get-hybrid-trie">get-hybrid-trie</A></B></code>  </TD><TD valign=top align=left> (key trie) </TR></TABLE> <TD valign=top align=right> <I>[accessor generic function]</I></TR></TABLE><DD>Returns the value for a <code>key</code> in a
   <code><A HREF="#trie">trie</A></code>, and t/nil if found.  The trie may consist of some
   mixture of <code><A HREF="#trie">trie</A></code> instances and <code><A HREF="#structure-trie">structure-trie</A></code>
   instances.  This function is equivalent to <code>gethash</code>.  The second
   value returned is true if an entry was found.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="get-hybrid-trie-returning-node">get-hybrid-trie-returning-node</A></B></code>  </TD><TD valign=top align=left> (key trie &optional default) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>Returns the value for a <code>key</code> in a
   <code><A HREF="#trie">trie</A></code>, and t/nil if found.  The trie may consist of some
   mixture of <code><A HREF="#trie">trie</A></code> instances and <code><A HREF="#structure-trie">structure-trie</A></code>
   instances.  The second value returned is true if an entry was found, and
   false otherwise.  The third value is the trie node locating the key in the
   trie's net, so that we can do a modify on the locative without having to
   do the get again.  This function has uses analogous to the old modify-hash
   of Zetalisp.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="get-hybrid-trie-returning-node-no-extend">get-hybrid-trie-returning-node-no-extend</A></B></code>  </TD><TD valign=top align=left> (key trie &optional default) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>Returns the value for a <code>key</code> in a
   <code><A HREF="#trie">trie</A></code>, and t/nil if found.  The trie may consist of some
   mixture of <code><A HREF="#trie">trie</A></code> instances and <code><A HREF="#structure-trie">structure-trie</A></code>
   instances.  The second value returned is true if an entry was found, and
   false otherwise.  The third value is the trie node so that we can do a
   modify on the locative without having to do the get again.  If the node is
   not found, we do NOT extend, so no the third returned value is not
   defined.  See also <code><A HREF="#get-hybrid-trie-returning-node">get-hybrid-trie-returning-node</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="get-structure-trie">get-structure-trie</A></B></code>  </TD><TD valign=top align=left> (key structure-trie) </TR></TABLE> <TD valign=top align=right> <I>[accessor function]</I></TR></TABLE><DD>Returns the value for a <code>key</code> in a <code><A HREF="#structure-trie">structure-trie</A></code>, and t/nil
   if found.  This function is equivalent to <code>gethash</code>.  The second
   value returned is true if an entry was found.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="get-structure-trie-returning-node">get-structure-trie-returning-node</A></B></code>  </TD><TD valign=top align=left> (key structure-trie &optional (default nil)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Returns the value for a <code>key</code> in a <code><A HREF="#structure-trie">structure-trie</A></code>, and t/nil
   if found.  The second value returned is true if an entry was found, and
   false otherwise.  The third value is the structure-trie node locating the key in the
   structure-trie's net, so that we can do a modify on the locative without having to
   do the get again.  This function has uses analogous to the old modify-hash
   of Zetalisp.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="get-structure-trie-returning-node-no-extend">get-structure-trie-returning-node-no-extend</A></B></code>  </TD><TD valign=top align=left> (key structure-trie &optional (default nil)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Returns the value for a <code>key</code> in a <code><A HREF="#structure-trie">structure-trie</A></code>, and t/nil
   if found.  The second value returned is true if an entry was found, and
   false otherwise.  The third value is the structure-trie node so that we can do a
   modify on the locative without having to do the get again.  If the node is
   not found, we do NOT extend, so no the third returned value is not
   defined.  See also <code><A HREF="#get-structure-trie-returning-node">get-structure-trie-returning-node</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="get-trie">get-trie</A></B></code>  </TD><TD valign=top align=left> (key trie) </TR></TABLE> <TD valign=top align=right> <I>[accessor function]</I></TR></TABLE><DD>Returns the value for a <code>key</code> in a <code><A HREF="#trie">trie</A></code>, and t/nil
   if found.  This function is equivalent to <code>gethash</code>.  The second
   value returned is true if an entry was found.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="get-trie-returning-node">get-trie-returning-node</A></B></code>  </TD><TD valign=top align=left> (key trie &optional (default nil)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Returns the value for a <code>key</code> in a <code><A HREF="#trie">trie</A></code>, and t/nil
   if found.  The second value returned is true if an entry was found, and
   false otherwise.  The third value is the trie node locating the key in the
   trie's net, so that we can do a modify on the locative without having to
   do the get again.  This function has uses analogous to the old modify-hash
   of Zetalisp.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="get-trie-returning-node-no-extend">get-trie-returning-node-no-extend</A></B></code>  </TD><TD valign=top align=left> (key trie &optional (default nil)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Returns the value for a <code>key</code> in a <code><A HREF="#trie">trie</A></code>, and t/nil
   if found.  The second value returned is true if an entry was found, and
   false otherwise.  The third value is the trie node so that we can do a
   modify on the locative without having to do the get again.  If the node is
   not found, we do NOT extend, so no the third returned value is not
   defined.  See also <code><A HREF="#get-trie-returning-node">get-trie-returning-node</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="hybrid-trie-all-values">hybrid-trie-all-values</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Returns a list of all of the values in the <code><A HREF="#trie">trie</A></code>.
   The trie may consist of some mixture of <code><A HREF="#trie">trie</A></code> instances and
   <code><A HREF="#structure-trie">structure-trie</A></code> instances.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="hybrid-trie-arcs">hybrid-trie-arcs</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[accessor generic function]</I></TR></TABLE><DD>Returns the list of arcs dangling from a given trie node.
   The trie may consist of some mixture of <code><A HREF="#trie">trie</A></code> instances and
   <code><A HREF="#structure-trie">structure-trie</A></code> instances.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="hybrid-trie-arcs-hashed-p">hybrid-trie-arcs-hashed-p</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>A predicate on <code><A HREF="#trie">trie</A></code> nodes that is true is the
   number of dependent arcs has grown large enough that it has flipped into
   hashing mode.  The trie may consist of some mixture of <code><A HREF="#trie">trie</A></code>
   instances and <code><A HREF="#structure-trie">structure-trie</A></code> instances.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="hybrid-trie-node-count">hybrid-trie-node-count</A></B></code>  </TD><TD valign=top align=left> (trie &optional (with-values t)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Returns the number of nodes in the <code><A HREF="#trie">trie</A></code> that have values.
   When <code>with-values</code> is true, returns only the number of nodes
   that value associated values.
   The trie may consist of some mixture of <code><A HREF="#trie">trie</A></code> instances and
   <code><A HREF="#structure-trie">structure-trie</A></code> instances.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="hybrid-trie-stash">hybrid-trie-stash</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[accessor generic function]</I></TR></TABLE><DD>Returns the stashed tail of the list in the trie.
   The trie may consist of some mixture of <code><A HREF="#trie">trie</A></code> instances and
   <code><A HREF="#structure-trie">structure-trie</A></code> instances.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="hybrid-trie-value">hybrid-trie-value</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[accessor generic function]</I></TR></TABLE><DD>Returns the value located at a <code><A HREF="#trie">trie</A></code> node.
   The trie may consist of some mixture of <code><A HREF="#trie">trie</A></code> instances and
   <code><A HREF="#structure-trie">structure-trie</A></code> instances.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="linearize-sexpr">linearize-sexpr</A></B></code>  </TD><TD valign=top align=left> (x) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Linearizes an sexpression <code>x</code>.  This is the same representation
   used in the trie indexing structure.  For example, the linearized version of
   the sexpr <code>(a (b) c . d)</code> is
   <code>(*start* a *start* b *end* c *dot* d)</code>.
   Also see <code><A HREF="#delinearize-sexpr">delinearize-sexpr</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="make-hybrid-trie">make-hybrid-trie</A></B></code>  </TD><TD valign=top align=left> (&rest inits) </TR></TABLE> <TD valign=top align=right> <I>[macro]</I></TR></TABLE><DD>Makes either a <code><A HREF="#trie">trie</A></code> or a <code><A HREF="#structure-trie">structure-trie</A></code>
   depending on the setting of the <code>use-minimal-tries</code> feature.
   The data structure created using this constructor should only be accessed
   using the <code>hybrid-</code> operations.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="make-root-trie">make-root-trie</A></B></code>  </TD><TD valign=top align=left> (&key ((:value #:value) +no-value+) ((:arcs #:arcs) (quote nil)) ((:stash #:stash) (quote nil)) ((:purpose #:purpose) (quote nil)) ((:up #:up) (quote nil))) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Makes a new empty <code><A HREF="#root-trie">root-trie</A></code>.  Initargs are <code>:up</code>
   and <code>:purpose</code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="make-structure-trie">make-structure-trie</A></B></code>  </TD><TD valign=top align=left> (&key ((:value #:value) +no-value+) ((:arcs #:arcs) (quote nil)) ((:stash #:stash) (quote nil))) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Makes a new empty <code><A HREF="#structure-trie">structure-trie</A></code> node.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="make-trie">make-trie</A></B></code>  </TD><TD valign=top align=left> () </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Makes a new empty <code><A HREF="#trie">trie</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="make-trie-remove-duplicate-state">make-trie-remove-duplicate-state</A></B></code>  </TD><TD valign=top align=left> (&key ((:trie #:trie) (make-trie)) ((:unique #:unique) (quote nil)) ((:tail #:tail) (quote nil)) ((:count #:count) 0) ((:coercer #:coercer) (quote nil))) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Constructor for <code><A HREF="#trie-remove-duplicate-state">trie-remove-duplicate-state</A></code>s.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="maphybrid-trie">maphybrid-trie</A></B></code>  </TD><TD valign=top align=left> (f trie &optional parent) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>Calls the function <code>f</code> on each key/value pair
   stored in the <code><A HREF="#trie">trie</A></code>.  The trie may consist of some mixture of
   <code><A HREF="#trie">trie</A></code> instances and <code><A HREF="#structure-trie">structure-trie</A></code> instances.
   Note that this is fairly expensive -- the key must be
   delinearized.  If you don't really need to use the key for the values in
   the trie, you should use <code><A HREF="#maptrie-values">maptrie-values</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="maphybrid-trie-nodes">maphybrid-trie-nodes</A></B></code>  </TD><TD valign=top align=left> (f trie &optional with-values) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>Calls the function <code>f</code> on each <code><A HREF="#trie">trie</A></code>
   node.  If <code>with-values</code> is true, the default, then only calls
   <code>f</code> on nodes with a value.  The trie may consist of some mixture
   of <code><A HREF="#trie">trie</A></code> instances and <code><A HREF="#structure-trie">structure-trie</A></code> instances.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="maphybrid-trie-nodes-remove-if">maphybrid-trie-nodes-remove-if</A></B></code>  </TD><TD valign=top align=left> (f trie &optional key) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>Maps over a <code><A HREF="#trie">trie</A></code> conditionally removing nodes.
   The nodes in the <code><A HREF="#trie">trie</A></code> are visited top-down.  The trie may
   consist of some mixture of <code><A HREF="#trie">trie</A></code> instances and
   <code><A HREF="#structure-trie">structure-trie</A></code> instances.  The function <code>f</code> is
   applied to three arguments: a <code><A HREF="#trie">trie</A></code>, a key, and a value.  The
   key is the label on the arc leading to this <code><A HREF="#trie">trie</A></code>.  The key will
   be nil for the top level trie.  If <code>f</code> returns true, then the
   subtree under the <code><A HREF="#trie">trie</A></code> is dismantled and the arc
   leading to it is removed.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="maphybrid-trie-values">maphybrid-trie-values</A></B></code>  </TD><TD valign=top align=left> (f trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Calls the function <code>f</code> on each value stored in the
   <code><A HREF="#trie">trie</A></code>.  The trie may consist of some mixture of
   <code><A HREF="#trie">trie</A></code> instances and <code><A HREF="#structure-trie">structure-trie</A></code> instances.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="mapstructure-trie">mapstructure-trie</A></B></code>  </TD><TD valign=top align=left> (f structure-trie &optional (parent nil supplied-p)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Calls the function <code>f</code> on each key/value pair stored in the
   <code><A HREF="#structure-trie">structure-trie</A></code>.  Note that this is fairly expensive -- the key must be
   delinearized.  If you don't really need to use the key for the values in
   the structure-trie, you should use <code><A HREF="#mapstructure-trie-values">mapstructure-trie-values</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="mapstructure-trie-nodes">mapstructure-trie-nodes</A></B></code>  </TD><TD valign=top align=left> (f structure-trie &optional (with-values t)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Calls the function <code>f</code> on each <code><A HREF="#structure-trie">structure-trie</A></code> node.  If
   <code>with-values</code> is true, the default, then only calls
   <code>f</code> on nodes with a value.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="mapstructure-trie-nodes-remove-if">mapstructure-trie-nodes-remove-if</A></B></code>  </TD><TD valign=top align=left> (f structure-trie &optional (key nil)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Maps over a <code><A HREF="#structure-trie">structure-trie</A></code> conditionally removing nodes.  The nodes in
   the <code><A HREF="#structure-trie">structure-trie</A></code> are visited top-down.  The function <code>f</code> is
   applied to three arguments: a <code><A HREF="#structure-trie">structure-trie</A></code>, a key, and a value.  The
   key is the label on the arc leading to this <code><A HREF="#structure-trie">structure-trie</A></code>.  The key will
   be nil for the top level structure-trie.  If <code>f</code> returns true, then the
   subtree under the <code><A HREF="#structure-trie">structure-trie</A></code> is dismantled and the arc
   leading to it is removed.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="mapstructure-trie-values">mapstructure-trie-values</A></B></code>  </TD><TD valign=top align=left> (f structure-trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Calls the function <code>f</code> on each value stored in the
   <code><A HREF="#structure-trie">structure-trie</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="maptrie">maptrie</A></B></code>  </TD><TD valign=top align=left> (f trie &optional (parent nil supplied-p)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Calls the function <code>f</code> on each key/value pair stored in the
   <code><A HREF="#trie">trie</A></code>.  Note that this is fairly expensive -- the key must be
   delinearized.  If you don't really need to use the key for the values in
   the trie, you should use <code><A HREF="#maptrie-values">maptrie-values</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="maptrie-nodes">maptrie-nodes</A></B></code>  </TD><TD valign=top align=left> (f trie &optional (with-values t)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Calls the function <code>f</code> on each <code><A HREF="#trie">trie</A></code> node.  If
   <code>with-values</code> is true, the default, then only calls
   <code>f</code> on nodes with a value.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="maptrie-nodes-remove-if">maptrie-nodes-remove-if</A></B></code>  </TD><TD valign=top align=left> (f trie &optional (key nil)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Maps over a <code><A HREF="#trie">trie</A></code> conditionally removing nodes.  The nodes in
   the <code><A HREF="#trie">trie</A></code> are visited top-down.  The function <code>f</code> is
   applied to three arguments: a <code><A HREF="#trie">trie</A></code>, a key, and a value.  The
   key is the label on the arc leading to this <code><A HREF="#trie">trie</A></code>.  The key will
   be nil for the top level trie.  If <code>f</code> returns true, then the
   subtree under the <code><A HREF="#trie">trie</A></code> is dismantled and the arc
   leading to it is removed.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="maptrie-values">maptrie-values</A></B></code>  </TD><TD valign=top align=left> (f trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Calls the function <code>f</code> on each value stored in the
   <code><A HREF="#trie">trie</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="member-using-state">member-using-state</A></B></code>  </TD><TD valign=top align=left> (x state) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Given an object <code>x</code> and a state object <code>state</code>, which
   is an instance of <code><A HREF="#remove-duplicates-using-state">remove-duplicates-using-state</A></code>, is true
   if <code>x</code> has already been recorded in the state.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="new-root-hybrid-trie">new-root-hybrid-trie</A></B></code>  </TD><TD valign=top align=left> (purpose up) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>The behavior of this function depends on the setting of the
   <code>use-minimal-tries</code> feature.  If this feature is set,
   a <code><A HREF="#trie">trie</A></code> will be created, and the <code>up</code>
   and <code>purpose</code> values will be ignored.  If the feature is not
   set, a new, empty <code><A HREF="#root-trie">root-trie</A></code>, initializing the <code>up</code>
   and <code>purpose</code> slots accordingly.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="new-root-trie">new-root-trie</A></B></code>  </TD><TD valign=top align=left> (purpose up) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Creates a new, empty <code><A HREF="#root-trie">root-trie</A></code>, initializing the <code>up</code>
   and <code>purpose</code> slots accordingly.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="pushnew-using-state">pushnew-using-state</A></B></code>  </TD><TD valign=top align=left> (x state &optional (stop-at nil)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Given an object <code>x</code> and a state object <code>state</code>, which
   is an instance of <code><A HREF="#remove-duplicates-using-state">remove-duplicates-using-state</A></code>, adds the
   element <code>x</code> to the state if it isn't already there according to
   an <code>equal</code> test.  If <code>stop-at</code> is an integer then
   the value is not added of the number of values already found in the state
   exceeds the <code>stop-at</code> value.  If <code>state</code> is nil, a new
   <code><A HREF="#remove-duplicates-using-state">remove-duplicates-using-state</A></code> object is created and returned
   as the fourth value.<P>

   Returns five values:
   <OL>
   <LI>The current list of items in the state.
   <LI>The number of items in the state.
   <LI>A flag that is true is the <code>stop-at</code> has been reached.
   <LI>The state object.
   <LI>A flag that is true of the argument <code>x</code> was found in the
       state.
   </OL>
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="reconstitute-from-hash-key">reconstitute-from-hash-key</A></B></code>  </TD><TD valign=top align=left> (x) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>The inverse operation of <code><A HREF="ok-utils-lisp-package-docs.html#fast-hash-key">ok-utils:fast-hash-key</A></code>.
   Takes a fast hash key and returns the associated object.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="remove-duplicates-equal-using-structure-trie">remove-duplicates-equal-using-structure-trie</A></B></code>  </TD><TD valign=top align=left> (list) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Takes a list and does an <code>equal</code> <code>remove-duplicates</code>
   on it using a <code><A HREF="#structure-trie">structure-trie</A></code> as an intermediate data structure.  This
   algorithm will be O(n) in the length of the list, and will be much faster
   than using a hash table for the same purpose as long as the elements in the
   list are potentially non-trivial.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="remove-duplicates-equal-using-structure-trie*">remove-duplicates-equal-using-structure-trie*</A></B></code>  </TD><TD valign=top align=left> (lists) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>This function is just like <code><A HREF="#remove-duplicates-equal-using-structure-trie">remove-duplicates-equal-using-structure-trie</A></code>,
   only it takesd a list of lists, and returns a list containing only the
   unique elements unioned across all of the lists.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="remove-duplicates-equal-using-trie">remove-duplicates-equal-using-trie</A></B></code>  </TD><TD valign=top align=left> (list) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Takes a list and does an <code>equal</code> <code>remove-duplicates</code>
   on it using a <code><A HREF="#trie">trie</A></code> as an intermediate data structure.  This
   algorithm will be O(n) in the length of the list, and will be much faster
   than using a hash table for the same purpose as long as the elements in the
   list are potentially non-trivial.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="remove-duplicates-equal-using-trie*">remove-duplicates-equal-using-trie*</A></B></code>  </TD><TD valign=top align=left> (lists) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>This function is just like <code><A HREF="#remove-duplicates-equal-using-trie">remove-duplicates-equal-using-trie</A></code>,
   only it takesd a list of lists, and returns a list containing only the
   unique elements unioned across all of the lists.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="remove-duplicates-using-state">remove-duplicates-using-state</A></B></code>  </TD><TD valign=top align=left> (list state &optional (stop-at nil)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Given a list <code>list</code> and a state object <code>state</code>, which
   is an instance of <code><A HREF="#remove-duplicates-using-state">remove-duplicates-using-state</A></code>, removes
   all of the ruplicates in the <code>list</code> according to
   an <code>equal</code> test.  If <code>stop-at</code> is an integer then
   nothing happens if the number of values already in the state
   exceeds the <code>stop-at</code> value.<P>

   Returns four values:
   <OL>
   <LI>The current list of items in the state.
   <LI>The number of items in the state.
   <LI>A flag that is true is the <code>stop-at</code> has been reached.
   <LI>The state object.
   </OL>
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="remove-duplicates-using-structure-trie-and-coercion">remove-duplicates-using-structure-trie-and-coercion</A></B></code>  </TD><TD valign=top align=left> (list function &optional (incoming-unique nil) (incoming-structure-trie (make-structure-trie))) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Removes the duplicates in <code>list</code> coercing the elements in the
   list first using the <code>function</code>.  <code>Incoming-unique</code>
   is an optional incoming uniquified list, all of whose elements are already in
   <code>incoming-structure-trie</code>.  These arguments are used to do multiple,
   repeated remove-duplicates calls over lots of lists.<P>

   Returns three values:
   <OL>
   <LI>The new list of unique elements
   <LI>The number of unique elements found this time.
   <LI>The outgoing modified <code><A HREF="#structure-trie">structure-trie</A></code>.
   </OL>
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="remove-duplicates-using-trie-and-coercion">remove-duplicates-using-trie-and-coercion</A></B></code>  </TD><TD valign=top align=left> (list function &optional (incoming-unique nil) (incoming-trie (make-trie))) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Removes the duplicates in <code>list</code> coercing the elements in the
   list first using the <code>function</code>.  <code>Incoming-unique</code>
   is an optional incoming uniquified list, all of whose elements are already in
   <code>incoming-trie</code>.  These arguments are used to do multiple,
   repeated remove-duplicates calls over lots of lists.<P>

   Returns three values:
   <OL>
   <LI>The new list of unique elements
   <LI>The number of unique elements found this time.
   <LI>The outgoing modified <code><A HREF="#trie">trie</A></code>.
   </OL>
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="remove-using-state">remove-using-state</A></B></code>  </TD><TD valign=top align=left> (x state) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Given an object <code>x</code> and a state object <code>state</code>, which
   is an instance of <code><A HREF="#remove-duplicates-using-state">remove-duplicates-using-state</A></code>, removes the
   element <code>x</code> from the state if it is already there according to
   an <code>equal</code> test.<P>

   Returns five values:
   <OL>
   <LI>The current list of items in the state.
   <LI>The number of items in the state.
   <LI>NIL
   <LI>The state object.
   <LI>A flag that is true of the argument <code>x</code> was found in the
       state.
   </OL>
<TABLE width=100%><DT><TR><TD valign=top> <code><B><A NAME="root-trie">root-trie</A></B></code> <TD valign=top align=right> <I>[defstruct]</I></TR></TABLE><DD>A defstruct for the root <code>trie</code> node for a <code>trie</code>
   discrimination net.  This class has no semantic difference from normal
   <code>trie</code> nodes, but it has slots that allow for a backpointer to
   the object containing the trie (<code>up</code>) and a reason for the
   trie being created in the first place (<code>purpose</code>).  These are
   useful in debugging.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="root-trie-purpose">root-trie-purpose</A></B></code>  </TD><TD valign=top align=left> (liquid::x) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>An accessor for the <code>purpose</code> slot in a <code><A HREF="#root-trie">root-trie</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="root-trie-up">root-trie-up</A></B></code>  </TD><TD valign=top align=left> (liquid::x) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>An accessor for the <code>up</code> slot in a <code><A HREF="#root-trie">root-trie</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="set-hybrid-trie-value">set-hybrid-trie-value</A></B></code>  </TD><TD valign=top align=left> (trie value) </TR></TABLE> <TD valign=top align=right> <I>[generic function]</I></TR></TABLE><DD>Sets the value slot at a given <code><A HREF="#trie">trie</A></code> node.
   The trie may consist of some mixture of <code><A HREF="#trie">trie</A></code> instances and
   <code><A HREF="#structure-trie">structure-trie</A></code> instances.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="set-structure-trie-value">set-structure-trie-value</A></B></code>  </TD><TD valign=top align=left> (structure-trie value) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Sets the value slot at a given <code><A HREF="#structure-trie">structure-trie</A></code> node.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="set-trie-value">set-trie-value</A></B></code>  </TD><TD valign=top align=left> (trie value) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Sets the value slot at a given <code><A HREF="#trie">trie</A></code> node.
<TABLE width=100%><DT><TR><TD valign=top> <code><B><A NAME="structure-trie">structure-trie</A></B></code> <TD valign=top align=right> <I>[defstruct]</I></TR></TABLE><DD>The tries implementation provides two distinct implementations of the trie
   data structure, one implented as cons cells, and called <code>trie</code>s,
   and the other implemented as defstructs, and called
   <code>structure-trie</code>s.  <code>Structure-trie</code>s use more
   space, but are much easier to understand in the debugger end inspector.
   If you think you might want to debug a <code>trie</code> data structure
   for any reason, you should use this one until fully debugged.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="structure-trie-all-values">structure-trie-all-values</A></B></code>  </TD><TD valign=top align=left> (structure-trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Returns a list of all of the values in the <code><A HREF="#structure-trie">structure-trie</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="structure-trie-arcs">structure-trie-arcs</A></B></code>  </TD><TD valign=top align=left> (liquid::x) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Accessor to get to the arcs dangling from a given a
   <code><A HREF="#structure-trie">structure-trie</A></code> node.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="structure-trie-arcs-hashed-p">structure-trie-arcs-hashed-p</A></B></code>  </TD><TD valign=top align=left> (structure-trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>A predicate that is structure-trie of a <code><A HREF="#structure-trie">structure-trie</A></code> node if the node has had
   enough arcs depending on it to push it into hashed mode.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="structure-trie-node-count">structure-trie-node-count</A></B></code>  </TD><TD valign=top align=left> (structure-trie &optional (with-values t)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Returns the number of nodes in the <code><A HREF="#structure-trie">structure-trie</A></code> that have values.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="structure-trie-p">structure-trie-p</A></B></code>  </TD><TD valign=top align=left> (liquid::x) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>A predicate that is true of <code><A HREF="#structure-trie">structure-trie</A></code> nodes.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="structure-trie-value">structure-trie-value</A></B></code>  </TD><TD valign=top align=left> (liquid::x) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Accessor to get to the value slot of a <code><A HREF="#structure-trie">structure-trie</A></code> node.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="trie-all-values">trie-all-values</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Returns a list of all of the values in the <code><A HREF="#trie">trie</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="trie-arcs">trie-arcs</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[accessor function]</I></TR></TABLE><DD>Returns the list of arcs dangling from a given trie node.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="trie-arcs-hashed-p">trie-arcs-hashed-p</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>A predicate that is trie of a <code><A HREF="#trie">trie</A></code> node if the node has had
   enough arcs depending on it to push it into hashed mode.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="trie-node-count">trie-node-count</A></B></code>  </TD><TD valign=top align=left> (trie &optional (with-values t)) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>Returns the number of nodes in the <code><A HREF="#trie">trie</A></code> that have values.
<TABLE width=100%><DT><TR><TD valign=top> <code><B><A NAME="trie-remove-duplicate-state">trie-remove-duplicate-state</A></B></code> <TD valign=top align=right> <I>[defstruct]</I></TR></TABLE><DD>A data structure used to support stateful remove-duplicates behavior.
   This is used by operations such as <code>pushnew-using-state</code>, and
   <code>remove-duplicates-using-state</code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="trie-remove-duplicate-state-count">trie-remove-duplicate-state-count</A></B></code>  </TD><TD valign=top align=left> (liquid::x) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>The number of objects held within the
   <code><A HREF="#trie-remove-duplicate-state">trie-remove-duplicate-state</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="trie-remove-duplicate-state-unique">trie-remove-duplicate-state-unique</A></B></code>  </TD><TD valign=top align=left> (liquid::x) </TR></TABLE> <TD valign=top align=right> <I>[function]</I></TR></TABLE><DD>The list or unique elements held within the
   <code><A HREF="#trie-remove-duplicate-state">trie-remove-duplicate-state</A></code>.
<TABLE width=100%><DT><TR><TD valign=top><TABLE><TR><TD valign=top> <code><B><A NAME="trie-value">trie-value</A></B></code>  </TD><TD valign=top align=left> (trie) </TR></TABLE> <TD valign=top align=right> <I>[accessor function]</I></TR></TABLE><DD>Returns the value located at a <code><A HREF="#trie">trie</A></code> node.
</DL>
</HTML>